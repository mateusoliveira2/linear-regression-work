---
title: ""
author: "Fanny Batista Vieira, Marcus Vinícius de Farias Barbosa e Mateus de Lima Oliveira"
date: "13 de maio de 2019"
output:
  html_document:
    code_folding: "hide"
    toc: yes
    toc_depth: 5
    toc_float:
      collapsed: no
    df_print: paged
---

## Pergunta a ser respondida: Quais departamentos quando investidos interferem no lucro das startups ?

```{r}
library(tidyverse)
options(scipen = 999)

dataset = read_csv(here::here("data/50_startups.csv"),
                 col_types = "dddcd")
```

## Análise Descritiva

### Visualização dos dados
OBS: Inserir Heatmap

```{r}
library(ggplot2)
ggplot(data = dataset) +
  geom_point(aes(x = Administration, y = Profit, color = State)) +
  facet_grid(State ~ .) +
  ggtitle('Administration Spend X Profit')

ggplot(data = dataset) +
  geom_point(aes(x = Marketing, y = Profit, color = State)) +
  facet_grid(State ~ .) +
  ggtitle('Marketing Spend X Profit')

ggplot(data = dataset) +
  geom_point(aes(x = ReD, y = Profit, color = State)) +
  facet_grid(State ~ .) +
  ggtitle('ReD Spend X Profit')

ggplot(data = dataset) +
  geom_bar(aes(State, fill = State)) +
  ggtitle('Administration X Profit')

ggplot(data = dataset) +
  geom_point(aes(x = State, y = Profit, color = State))

```

### Análise da Correlação

```{r}
cor(dataset$Administration, dataset$Profit)
cor(dataset$Marketing, dataset$Profit)
cor(dataset$ReD, dataset$Profit)
```

## Modelo de Regressão

### Preprocessamento dos dados

Antes de analisar os modelos que se adequam à problemática proposta, é necessário adaptar as variáveis que não são do tipo númerico, pois sem isto, elas não podem ser consideradas como parâmetros dos modelos de uma regressão linear.

A variável adaptada é a Estado, que pode possuir três valores categóricos: New York, California e Florida. Desse modo, ela foi transformada para receber respectivamente os valores 1, 2 e 3, possibilitando sua inclusão nos modelos construídos.

```{r}
dataset$State = factor(dataset$State,
                       levels = c('New York', 'California', 'Florida'),
                       labels = c(1, 2, 3))
```

É necessário também dividir o conjunto de dados, em dois conjuntos: de treinamento e de teste. O conjunto de dados de treinamento é utilizado para construir e treinar o modelo, já o de testes é utilizado para verificar o quão acertivo está o modelo.
Forma utilizados 80% dos dados para o conjunto de treinamento e 20% para o conjunto de teste.

```{r}
library(caTools)
set.seed(100)
split = sample.split(dataset$Profit, SplitRatio = 0.8)

training_set = subset(dataset, split == TRUE)
test_set = subset(dataset, split == FALSE)
```

### Encontrando o melhor modelo

A fim de encontrar o melhor modelo é utilizada a técnica Backward Elimination. Através da qual é criado um primeiro modelo considerando todas as variáveis independentes, e a partir disso vão sendo excluídas, uma por uma, as variáveis que não são relevantes para predição.

```{r}
regressor = lm(formula = Profit ~ .,
               data = training_set)
summary(regressor)
```
```{r}
regressor = lm(formula = Profit ~ Marketing + ReD + State,
               data = training_set)
summary(regressor)
```
```{r}
regressor = lm(formula = Profit ~ Marketing + ReD,
               data = training_set)
summary(regressor)
```
Modelo em que todos os estimadores dos parâmetros foram significativos.

```{r}
regressor = lm(formula = Profit ~ ReD,
               data = training_set)
summary(regressor)
```

## Análise de Resíduos

Os resíduos representam as diferenças entre os valores do fenômeno que estamos observando, no nosso caso, são os valores que observamos no dataset. E os valores estimados, a partir do nosso modelo. De modo formal, um resíduo pode ser obtido pela seguinte fórmula:

```
    ei = yi - yi'
```

onde:  
ei -> indica o iésimo erro  
yi -> indica o iésimo valor observado  
yi'-> indica o iésimo valor estimado  

A análise dos resíduos, consiste em validar se o modelo adotado, de fato, é adequado para o contexto do problema, baseado nas suposições feitas para os dados, são elas: 

 - **Linearidade**: Esperamos que os dados tenham uma relação linear.  
 - **Normalidade**: Os resíduos devem seguir a distribuição normal, com média igual a 0 e variância constante.  
 - **Homogeneidade**: Os resíduos devem variar na mesma proporção. Desta forma, cada um contribui de forma igual para a soma dos quadrados.  
 - **Independência**: Um resíduo não deve influenciar o outro, essa suposição, garante que os dados foram coletados de modo aleatório no espaço amostral.


No gráfico abaixo, vemos os valores observados, representados pelos círculos ao longo da reta, os valores estimados, indicados pelos círculos coloridos maiores, e os resíduos, que são as linhas entre os valores estimados e os observados.

A partir dele, conseguimos visualizar a existência da relação linear entre as variáveis, e como o modelo consegue explicar boa parte dos dados, conforme visto utilizando a estatística `R²`, que teve valor igual a 94%, demonstrando assim, que conseguimos explicar 94% dos dados.


```{r}
predicoes = predict(regressor)
residuos = residuals(regressor)

ggplot(training_set, aes(x = ReD, y = Profit)) +
  geom_smooth(method = "lm", se = FALSE, color = "lightgrey") +     # regression line  
  geom_segment(aes(xend = ReD, yend = predicoes), alpha = .2) +     # draw line from point to line
  geom_point(aes(color = abs(residuos), size = abs(residuos))) +    # size of the points
  scale_color_continuous(low = "green", high = "red") +             # colour of the points mapped to residual size - green smaller, red larger
  guides(color = FALSE, size = FALSE) +                             # size legend removed
  geom_point(aes(y = predicoes), shape = 1) +
  theme_bw() 
```

### Teste da linearidade

```{r}
plot(regressor, which=1, col=c("blue"))
```


### Teste de normalidade

```{r}
plot(regressor, which=2, col=c("blue"))
```

```{r}
plot(density(residuos))
```

```{r}
shapiro.test(residuos)
```

### Teste da homogeinidade

```{r}
plot(regressor, which=3, col=c("blue"))  # Scale-Location Plot
```

```{r}
library(lmtest)
bptest(regressor, studentize = F)
```

### Teste da independência

```{r}
library(car)
durbinWatsonTest(regressor)
```

